(* Examples from "Time Warps for Guarded Recursion" *)

extern not : `(ω) ⊛ (bool → bool)

extern tail : `(ω) ⊛ (stream bool → `0(1) ⊛ stream bool)

rec
{
  const (x : int) : stream int =
    x :: (const x) by `0(1);

  map (f : int → int) ((x :: xs) : stream int) : stream int =
    f x :: (map f xs) by `0(1);

  zipWith
    (f : int → int → int)
    ((x :: xs) : stream int)
    ((y :: ys) : stream int) : stream int =
    (f x y) :: (zipWith f xs ys) by `0(1);
}

{
  plus (x : int) (y : int) : int = x + y;
}

{
  zero = const 0;

  incr = map (λ (x : int) ⇒ x + 1);

  one = incr zero;
}

rec
{
  nat : stream int =
    0 :: (map (λ (x : int) ⇒ x + 1) nat) by `0(1);
}

rec
{
  h ((x :: xs) : stream bool) : `(2) ⊛ stream bool =
    let { ys = (h xs) by `0(1) } in
      (x :: (not x :: ys) by `0(1)) by `(2);
}

rec
{
  thuemorse : stream bool =
    let { ys = (h thuemorse) by `0(1) } in
      false :: (tail ys) by `0(2);
}

rec
{
  nat : `(1 0) ⊛ stream int = (0 :: pos) by `(1 0);

  pos : `(0 1) ⊛ stream int = (incr nat) by `(0 1);
}

extern tail : `(ω) ⊛ (stream int → `0(1) ⊛ stream int)

rec
{
  fib : stream int =
    let { ys = (tail fib) by `0(1) } in
    0 :: (1 :: (zipWith plus fib ys) by `0(1)) by `0(1);
}
